<!--
  - Copyright (c) 2016 Neto Ranito & Seabra LDA. All rights reserved.
  -
  - This file is part of casper-combolist.
  -
  - casper-combolist is free software: you can redistribute it and/or modify
  - it under the terms of the GNU Affero General Public License as published by
  - the Free Software Foundation, either version 3 of the License, or
  - (at your option) any later version.
  -
  - casper-combolist  is distributed in the hope that it will be useful,
  - but WITHOUT ANY WARRANTY; without even the implied warranty of
  - MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  - GNU General Public License for more details.
  -
  - You should have received a copy of the GNU Affero General Public License
  - along with casper-combolist.  If not, see <http://www.gnu.org/licenses/>.
  -
 -->

<link rel="import" href="../polymer/polymer.html">
<!--link rel="import" href="../iron-autogrow-textarea/iron-autogrow-textarea.html"-->
<link rel="import" href="../iron-input/iron-input.html">
<link rel="import" href="../iron-icon/iron-icon.html">
<link rel="import" href="../casper-epaper/casper-epaper-tooltip.html">
<link rel="import" href="../casper-epaper/casper-epaper-datepicker.html">
<link rel="import" href="../casper-epaper/casper-epaper-combolist.html">

<!--
`casper-epaper-input` customised input component that overlays the rendering canvas
-->
<dom-module id="casper-epaper-input">
  <style>
    :host {
      display: none;
      position: absolute;
    }

    iron-icon {
      position: absolute;
      cursor: pointer;
      padding: 1px;
      margin: 0px;
      transition: transform 300ms;
      fill: var(--dark-theme-background-color);
    }

    iron-icon[rotate] {
      transform: rotate(180deg);
    }

    iron-icon:hover {
      fill: var(--primary-color);
    }

    ::-ms-clear {
      display: none;
    }

    ::selection {
      background: #d0ecf0; 
    }

    #textarea {
      border: none;
      display: block;
      position: absolute;
      padding: 0px;
      margin: 0px;
      outline: none;
      background-color: rgba(0, 0, 0, 0); 
    }
/*
    #input {
      -ms-overflow-style: -ms-autohiding-scrollbar;
    }

    #textarea {
      resize: none;
      background-color: rgba(0, 0, 0, 0); 
      border-color: rgba(0, 0, 0, 0);
      overflow: auto;
    }*/

  </style>
  <template>
    <!--div id="input"-->
    <input is="iron-input" id="textarea">
    <!--/div-->
    <!--iron-autogrow-textarea id="input" tabindex="0"></iron-autogrow-textarea-->
    <iron-icon id="dropdown_btn" rotate$="[[overlayVisible]]" on-tap="_toggleOverlay" icon="casper-icons:arrow-drop-down"></iron-icon>
    <iron-icon id="edit_btn" on-tap="_toggleSubEditor" icon="casper-icons:cancel"></iron-icon>
    <casper-epaper-combolist id="combo"></casper-epaper-combolist>
    <casper-epaper-datepicker id="date"></casper-epaper-datepicker>
  </template>
  <script>
    Polymer({
      is: 'casper-epaper-input',

      properties: {
        /** True when there is an open overlay */
        overlayVisible: {
          type: Boolean,
          value: false
        },
        /** Parent casper-epaper element that owns the this helper */
        epaper: {
          type: Object
        }
      },

      listeners: {
        'keypress': '_onKeypress',
        'keydown': '_onKeyDown',
        'mousedown': '_onMouseDown',
        'mouseup': '_onMouseUp',
        'tap': '_onTap'
      },

      ready: function () {
        //this._input          = this.$.input;
        this._binding        = undefined;
        this._textArea       = this.$.textarea;//this.$.input.$.textarea;
        this.$.date.inputBox = this.$.textarea;//this.$.input.$.textarea;
        this._visible        = true;
        this.setVisible(false);
        this.$.combo.setPositionTarget(this);
      },

      attached: function () {
        this._initialSelection = false;
        this._mode             = 'n';
        this._comboFilter      = '';
        this.overlayVisible    = false;
        this._overlay          = undefined;
        this._comboListQuery   = undefined;
        this.listen(this.$.combo, 'on-combo-list-closed'      , '_onComboListClosed');
        this.listen(this.$.combo, 'on-combo-selection-changed', '_onComboSelectionChanged');
        this.listen(this.$.date , 'date-overlay-closed'       , '_onDateOverlayClosed');
      },

      detached: function () {
        this._clearModel();
        this.unlisten(this.$.combo, 'on-combo-list-closed'      , '_onComboListClosed');
        this.unlisten(this.$.combo, 'on-combo-selection-changed', '_onComboSelectionChanged');
        this.unlisten(this.$.date , 'date-overlay-closed'       , '_onDateOverlayClosed');
      },

      /**
       * Show or hide the input control
       *
       * @param {boolean} visible
       */
      setVisible: function (visible) {
        if ( this._visible !== visible ) {
          if ( visible ) {
            this.style.display = 'inline-block';
          } else {
            this.style.display                = 'none';
            this.$.dropdown_btn.style.display = 'none';
            this.$.edit_btn.style.display     = 'none';
          }
          this._visible = visible;
        }
      },

      /**
       * Position and size the input overlay on top the editable element
       *
       * @param {number} x Upper left corner (x)
       * @param {number} y Upper left corner (y)
       * @param {number} w box width in px
       * @param {number} h box height in px
       */
      alignPosition: function (x, y, w, h) {
        this.style.left           = x + 'px';
        this.style.top            = y + 'px';
        this.style.width          = w + 'px';
        this.style.height         = h + 'px';
        /*_input*/this._textArea.style.left    = '0px';
        /*_input*/this._textArea.style.top     = '0px';
        /*_input*/this._textArea.style.width   = w + 'px';
        /*_input*/this._textArea.style.height  = h + 'px';
        /*_input*/this._textArea.scrollTop     = 0;
        /*_input*/this._textArea.scrollLeft    = 0;
        this._x                   = x;
        this._y                   = y;
      },

      /**
       * Align the HTML input text size baseline and left edge with the text drawn in the canvas, also sets color
       *
       * @param {number} a_text_left   Starting point of left aligned text # TODO paddding
       * @param {number} a_baseline    Vertical baseline of the first text line # TODO remove??? or do PADDING?
       */
      alignStyle: function (a_text_left, a_baseline) {

        // Make baseline and edge relative to input pox 
        var ratio = this.epaper._ratio;
        var tl    = a_text_left / ratio - this._x;
        var bl    = a_baseline  / ratio - this._y;
        var top   = this._f_top / ratio;

        /*console.log(' ==> tl=' + tl + ' bl=' + bl + ' top=' + top);*/


        //this._textArea.style.padding     = '0px'; 
        //this._textArea.style.margin      = '0px'; 
        this._textArea.style.marginLeft  = Math.max(tl,1) + 'px';
        this._textArea.style.marginRight = Math.max(tl,1) + 'px';
        //this._textArea.style.marginTop   = Math.max(bl + top, 1) + 'px';
        this._textArea.style.fontFamily  = this.epaper._font_spec[this.epaper._FONT_NAME_INDEX];
        this._textArea.style.fontSize    = this.epaper._font_spec[this.epaper._SIZE_INDEX] / ratio + 'px';
        this._textArea.style.color       = this.epaper._text_color;
      },

      hideOverlays: function () {
        this.hideTooltip();
        this._setOverlay(undefined);
        this.$.combo.setVisible(false);
      },

      setCasperBinding: function (binding) {
        this._binding = binding;
        if ( binding !== undefined ) {
          switch(binding.attachment.type) {
            case 'dropDownList':
            case 'dropDownTree':
              this.setMode('c');
              break;
            case 'checkbox':
            case 'radioButton':
              this.setMode('R');
              break;
            default:
              this.setMode('n');
              break;
          }
          this.$.combo.setCasperBinding(binding);
          this.setCombolistQuery(binding.attachment.route);
          if ( binding.hint && binding.hint.expression && binding.hint.expression.length ) {
            this.showTooltip(binding.hint.expression);
          } else {
            this.hideTooltip();
          }
        } else {
          this.$.combo.setCasperBinding(undefined);
          this.setCombolistQuery(undefined);
        }
      },

      /**
       * Configure the editor mode
       *
       * @param a_mode The editor mode
       * @param a_nullable_list The combo box list can be nulled
       */
      setMode: function (a_mode, a_nullable_list) {
        var top, left, width, height, btn_size;

        this.hideOverlays();
        this._comboFilter = '';
        this._mode        = a_mode;
        switch ( a_mode ) {
        case 'c': // Client combo
          this._textArea.style.cursor = 'pointer';
          this._setOverlay(this.$.combo);
          break;
        case 'l': // Ledger mode
          this._textArea.style.cursor = 'text';
          this._setOverlay(this.$.combo);
          break;
        case 'd': // Date
          this._textArea.style.cursor = 'text';
          this._setOverlay(this.$.date);
          break;
        case 'R': // Radio
          this._textArea.style.cursor = 'pointer';
          this._setOverlay(undefined);
          break;
        default: // Normal mode the default
          this._textArea.style.cursor = 'text';
          this._mode = 'n'
          this._setOverlay(undefined);
          break;
        }

        btn_size = Math.floor(12 * this.epaper.zoom); 
        width    = parseInt(this.style.width);
        height   = parseInt(this.style.height);

        this.$.dropdown_btn.style.padding = '0px';
        this.$.dropdown_btn.style.height  = btn_size + 'px';
        this.$.dropdown_btn.style.width   = btn_size + 'px';
        this.$.dropdown_btn.style.top     = ((height - btn_size) / 2) + 'px';
        this.$.dropdown_btn.style.left    = (width - btn_size) + 'px';

        // TODO edit button layout
        this.$.edit_btn.style.top        = ((height - btn_size) / 2) + 'px';
        this.$.edit_btn.style.left       = width + 'px';

        switch ( this._mode ) {
        case 'c': // Client combo
        case 'l': // Ledger mode
          this.$.dropdown_btn.icon = 'casper-icons:arrow-drop-down';
          this.$.dropdown_btn.style.display = 'inline';
          this._textArea.style.width = (width - btn_size) + 'px';
          break;
        case 'd': // Date
          this.$.dropdown_btn.icon = 'casper-icons:date-range'
          this.$.dropdown_btn.style.display = 'inline';
          this._textArea.style.width = (width - btn_size) + 'px';
          break;
        case 'R': // Radio
        default:  // Normal mode the default
          this.$.dropdown_btn.style.display = 'none';
          this.$.edit_btn.style.display = 'none';
          this._textArea.style.width = (width) + 'px';
          break;
        }
      },

      /**
       * Sets the name of the data model field that contains the item description
       *
       * @param a_display_fields array of fields names
       */
      setDisplayFields: function (a_fields) {
        this.$.combo.setDisplayFields(a_fields);
      },

      /**
       * Sets the basic the combo item list
       *
       * Each model is associated with an id, models are kept in a model cache. To set a model the
       * server specified the id and json model, to reuse a cached model just sends the id.
       *
       * @param combo_id Unique identifier of the combo list in the document (no caching if it's undefined)
       * @param json json string with the data model to associate with the combo it. If this parameter is
       *               undefined the model is retrieved from the _modelCache
       */
      setModelFromJson: function (combo_id, json) {
        this._comboListQuery = undefined;
        this.$.combo.$.spinner.active = false;
        this.$.combo.showFab = false;
        return this.$.combo.setModelFromJson(combo_id, json);
      },

      setCombolistQuery: function (query) {
        this._comboListQuery = query;
        this._textArea.value = '';
        this._textArea.selectionStart = undefined;
        this._textArea.selectionEnd = undefined;
        this.$.combo.clearModel();
        this.$.combo.$.spinner.active = true;
      },

      onGetDataResponse: function (jsonapi) {
        this.$.combo.$.spinner.active = false;
        this.$.combo.setModelFromJsonApi(jsonapi);
        this._layoutComboList();
        this.$.combo.$.dialog.fire('iron-overlay-opened');
      },

      _setOverlay: function (overlay) {
        if ( this._overlay !== undefined ) {
          this._overlay.setVisible(false);
        }
        this._overlay = overlay;
        this.overlayVisible = false;
      },

      _toggleOverlay: function (event) {
        if ( this._overlay !== undefined ) {
          if ( this.overlayVisible ) {
            this._overlay.setVisible(false);
          } else {
            if ( this._overlay === this.$.combo ) {
              this._layoutComboList();
            }
            this.hideTooltip();
            this._overlay.setVisible(true, this._comboFilter);
            if ( this._comboListQuery !== undefined && this._overlay === this.$.combo ) {
              this.epaper.send_command('get data "'+this._comboListQuery+'";');
            }
          }
          this.overlayVisible = this._overlay.isVisible();
        }
        if ( event !== undefined ) {
          event.stopPropagation();
        }
      },

      /**
       * Show the combo box list
       */
      _layoutComboList: function () {
        var sc = this.epaper._ratio;
        var page_margin = 40 * this.epaper._ratio;
        var max_width, max_height;

        var left  = parseInt(this.style.left);
        var width = parseInt(this.style.width);

        if ( (left / this.epaper._sx) > this.epaper._page_width / 2 ) {
          max_width = left + width /*+ this._open_combo_button._bb_w*/ - page_margin;
        } else {
          max_width = this.epaper._page_width * this.epaper._sx - page_margin - left;
        }

        this.$.combo.autoSize(width, max_width);
        if ( ! this.$.combo.isVisible() && this._overlay === this.$.combo ) {
          this.$.combo.setVisible(true, this._comboFilter);
        }
      },

      setValue: function (value, displayValue) {
        switch ( this._mode) {
          case 'c':
            this._setValueC(value, displayValue);
            break;
          case 'd':
            this._setValueD(value);
          case 'n':
          default:
            this._setValueN(value);
            break;
        }
      },

      grabFocus: function () {
        if ( this._initialSelection === true ) {
          if ( this._mode === 'c' ) {
            this._textArea.selectionStart = undefined;
            this._textArea.selectionEnd   = undefined;
          } else {
            this._textArea.selectionStart = 0;
            this._textArea.selectionEnd   = this._textArea.value.length;
          }
        }
        this._textArea.focus();
      },

      _onTap: function (event) {
        switch ( this._mode) {
          case 'c':
            this._toggleOverlay();
            event.preventDefault();
            break;
          default:
            break;
        }
      },

      _onKeypress: function (event) {
        switch ( this._mode) {
          case 'c':
            this._onKeypressC(event);
            break;
          case 'R':
            this._onKeypressR(event);
            break;
          //case 'l': // TODO LEDGER MODE
          //  this._onKeyDown_l(event);
          //  break;
          case 'n':
          default:
            break;
        }
      },

      _onKeyDown: function (event) {
        switch ( this._mode) {
          case 'c':
            this._onKeyDownC(event);
            break;
          case 'R':
            this._onKeyDownR(event);
            break;
          //case 'l': // TODO LEDGER MODE
          //  this._onKeyDown_l(event);
          //  break;
          case 'n':
          default:
            this._onKeyDownN(event);
            break;
        }
      },

      /*****************************************************************************************/
      /*                                                                                       */
      /*                             ~~~ N Mode Normal Mode ~~~                                */
      /*                                                                                       */
      /*****************************************************************************************/

      _setValueN: function (value) {
        this._textArea.value          = value;
        this._textArea.selectionStart = 0;
        this._textArea.selectionEnd   = value.length;
        this._initialSelection        = true;
      },

      _onKeyDownN: function (event) {
        var vkey = this._keycodeToVkey(event);

        if ( this._initialSelection === true ) {
          if ( ['down', 'up', 'left', 'right'].indexOf(vkey) > -1 ) {
            this.epaper.send_command('set key "focus_'+vkey+'";');
            event.preventDefault();
            return;
          } else if ( ['tab', 'shift+tab'].indexOf(vkey) > -1 ) {
            this.epaper.send_command('set key "'+vkey.replace(/\+/g, '"+"')+'";');
            event.preventDefault();
            return;
          } else if ( ['enter', 'F2'].indexOf(vkey) > -1 ) {
            this._textArea.selectionStart = this._textArea.value.length;
            this._textArea.selectionEnd = this._textArea.value.length;
            this._initialSelection = false;
            event.preventDefault();
            return;
          } else {
            this._initialSelection = false;
          }
        }

        if ( ['enter', 'tab', 'shift+tab'].indexOf(vkey) > -1 ) {
          this.epaper.send_command('set text "' + this._escapeForServer(this._textArea.value) + '" true; set key "'
                                      + vkey.replace(/\+/g, '"+"') + '";');
          event.preventDefault();
          return;
        }
      },

      /*****************************************************************************************/
      /*                                                                                       */
      /*                             ~~~ C Mode Client Combo ~~~                               */
      /*                                                                                       */
      /*****************************************************************************************/

      _setValueC: function (id, displayValue) {
        this.$.combo.setVisible(false);
        if ( id !== undefined && id.length > 0 ) {
          this.$.combo.selectById(id);
        } else {
          this._textArea.value = '';
        }
        this.overlayVisible = false;
        this._textArea.selectionStart = undefined;
        this._textArea.selectionEnd = undefined;
        if (this._comboListQuery !== undefined && displayValue !== undefined) {
          this._textArea.value = displayValue;
        }
      },

      _onKeypressC: function (event) {
        if ( this.overlayVisible === false ) {
          this._comboFilter += event.key;
          this.$.combo.setQuery(this._comboFilter);
          event.preventDefault();
        }
      },

      _onKeyDownC: function (event) {
        var vkey;

        vkey = this._keycodeToVkey(event);
        if ( this.overlayVisible === false ) {
          if ( ['down', 'up', 'left', 'right'].indexOf(vkey) > -1 ) {
            if ( this._comboFilter.length !== 0 && ['down', 'up'].indexOf(vkey) > -1) {
              this.$.combo.moveSelection(vkey);
            } else {
              this.epaper.send_command('set key "focus_'+vkey+'";');
            }
            event.preventDefault();
          } else if ( ['tab', 'shift+tab', 'enter'].indexOf(vkey) > -1 ) {
            if ( this.$.combo.getSelectedId() && this.$.combo.getSelectedId() !== this.$.combo.getInitialId() ) {
              this.epaper.send_command('set list item "' + this.$.combo.getSelectedId()  + '";');
            }
            this.epaper.send_command('set key "'+vkey.replace(/\+/g, '"+"')+'";');
            event.preventDefault();
          } else if ( vkey === 'alt' ) {
            this._toggleOverlay();
          } else if ( ['delete', 'backspace'].indexOf(vkey) > -1 ) {
            this._comboFilter = this._comboFilter.slice(0, -1);
            this.$.combo.setQuery(this._comboFilter, false);
            event.preventDefault();
          }
        } else {
          if ( vkey === 'esc' ) {
            this.$.combo.setVisible(false);
            this.overlayVisible = false;
            event.preventDefault();
          }
        }
      },

      _onComboSelectionChanged: function (event) {
        if ( event.detail.displayValue ) {
          this._textArea.value = event.detail.displayValue;
          if ( this._mode === 'c' && this.overlayVisible === false) {
            this._textArea.selectionStart = event.detail.matchStart;
            this._textArea.selectionEnd   = event.detail.matchEnd;
          }
        }
      },

      _onComboListClosed: function (event) {
        var key;

        this.overlayVisible = false;
        this._comboFilter    = '';

        key = event.detail.closingKey;
        if ( event.detail.selectedId !== undefined && event.detail.selectedId !== event.detail.previousId ) {
          this.epaper.send_command('set list item "' + event.detail.selectedId  + '";');
          if ( key === 'shift+tab' ) {
            this.epaper.send_command('set key "shift"+"tab";');
          } else if ( key === 'enter' || key === 'tab' ) {
            this.epaper.send_command('set key "tab";');
          } else {
            this.epaper.send_command('set key "save";');
          }
        } else {
          if ( key === 'shift+tab' ) {
            this.epaper.send_command('set key "focus_left";');
          } else if ( key === 'enter' || key === 'tab' ) {
            this.epaper.send_command('set key "focus_right";');
          }
        }
        this._textArea.focus();
      },

      /*****************************************************************************************/
      /*                                                                                       */
      /*                                 ~~~ D Mode date ~~~                                   */
      /*                                                                                       */
      /*****************************************************************************************/

      _setValueD: function (date) {
        this.$.date.setLocale('pt');     // TODO from server
        this._dateFormat = 'DD/MM/YYYY'; // TODO from server
        this.$.date.setValue(moment(date, this._dateFormat).format('YYYY-MM-DD'));
      },

      _onDateOverlayClosed: function (event) {
        this.overlayVisible = false;
        var vkey = event.detail.closingKey;
        var cmd  = '';

        if ( event.detail.previousDate !== event.detail.currentDate && vkey !== 'esc' ) {
          cmd = 'set text "'+event.detail.currentDate+'" true; ';
          if ( vkey === undefined ) {
            vkey = 'save';
          }
        }
        if ( vkey !== 'esc' && vkey !== undefined ) {
          cmd += 'set key "'+vkey.replace(/\+/g, '"+"')+'";';
        }
        if ( cmd.length ) {
          this.epaper.send_command(cmd);
        }
      },

      /*****************************************************************************************/
      /*                                                                                       */
      /*                             ~~~ R Mode Radio Button ~~~                               */
      /*                                                                                       */
      /*****************************************************************************************/

      _onKeypressR: function (event) {
        event.preventDefault();
      },

      _onKeyDownR: function (event) {
        if ( event.keyCode === 32 || (event.keyCode === 88 && this._textArea.value.length === 0) ) {
          this.debounce('casper-toggle', function () {
            this.epaper.send_command('set key "toggle";');
          }.bind(this), 300);
        } else {
          var vkey = this._keycodeToVkey(event);

          if ( ['down', 'up', 'left', 'right'].indexOf(vkey) > -1 ) {
            this.epaper.send_command('set key "focus_'+vkey+'";');
          } else if ( vkey === 'shift+tab' ) {
            this.epaper.send_command('set key "focus_left";');
          } else if ( vkey === 'enter' || vkey === 'tab' ) {
            this.epaper.send_command('set key "focus_right";');
          }
        }
        event.preventDefault();
      },

      /*****************************************************************************************/
      /*                                                                                       */
      /*                             ~~~ Input helper functions ~~~                            */
      /*                                                                                       */
      /*****************************************************************************************/

      /**
       * Escapes double quotes for the server protocol
       */
      _escapeForServer:  function (text) {
        return text.split('"').join('""');
      },

      /**
       * Convert keycode to virtual key code that is understood by the server
       *
       * @param event The Keyboard event
       *
       * @return the virtual key name or null if there no mapping
       */
      _keycodeToVkey: function (event) {
        switch (event.keyCode) {
        case  8: // backspace
          return 'backspace';
        case  9: // tab
          if ( event.shiftKey === true ) {
            return 'shift+tab';
          } else {
            return 'tab';
          }
          break;
        case 13: // enter
          return 'enter';
        case 27: // escape
          return 'esc';
        case 32: // space
          return ' ';
        case 37: // left
          return 'left';
        case 39: // right
          return 'right';
        case 38: // up
          if ( event.shiftKey === true ) {
            return 'shift+up';
          } else {
            return 'up';
          }
          break;
        case 40: // down
          if ( event.shiftKey === true ) {
            return 'shift+down';
          } else {
            return 'down';
          }
          break;
        case 46:
          return 'delete';
        case 65:
          if ( event.ctrlKey ) {
            return 'ctrl+a';
          }
          break;
        case 69:
          if ( event.ctrlKey ) {
            return 'ctrl+e';
          }
          break;
        case 75:
          if ( event.ctrlKey ) {
            return 'ctrl+k';
          }
          break;
        case 113:
          return 'F2';
        case 16:
          return 'shift';
        case 17:
          return 'ctrl';
        case 18:
          return 'alt';
        case 91:
          return 'window+left';
        case 92:
          return 'window+right';
        default:
          break;
        }
        return null;
      },

      /*****************************************************************************************/
      /*                                                                                       */
      /*                                ~~~ Mice handler ~~~                                   */
      /*                                                                                       */
      /*****************************************************************************************/

      _onMouseDown: function (event) {
        if ( this._mode === 'R' ) {
          event.preventDefault();
          this.epaper.send_command('set key "toggle";'); 
        } else {
          this._initialSelection = false;
          this.grabFocus();
        }
      },

      _onMouseUp: function (event) {
        if ( this._mode === 'R' ) {
          event.preventDefault();
        }
      },

      /*****************************************************************************************/
      /*                                                                                       */
      /*                            ~~~ Tooltip management ~~~                                 */
      /*                                                                                       */
      /*****************************************************************************************/

      /**
       * Called when the server updates the tooltip, passes the bounding box and text
       *
       * If the mid point of the server bounding box is not inside the current input bounds discard the update, this
       * test discards tooltip updates that came too late and are no longer related to the focused field
       *
       * @param left leftmost corner of server's field bounding box
       * @param top upper corner of server's field bounding box
       * @param width of the server's field bounding box
       * @param height of the server's field bounding box
       * @param content the new tooltip content
       */
      serverTooltipUpdate: function (left, top, width, height, content) {
        var mid_x, mid_y, bbi, bbc;

        bbc = this.epaper.$.canvas.getBoundingClientRect();
        bbi = this.$.input.getBoundingClientRect();
        mid_x = bbc.left + left + width  / 2;
        mid_y = bbc.top  + top  + height / 2;

        // ... if the mid point of the tooltip hint is outside the editor bounding box discard it ...
        if ( mid_x < bbi.left || mid_x > bbi.right || mid_y < bbi.top || mid_y > bbi.bottom ) {
          return;
        }
        if ( content.length ) {
          this.epaper.$.tooltip.show(content);
        } else {
          this.hideTooltip();
        }
      },

      showTooltip: function (content, positionTarget) {
        this.epaper.$.tooltip.show(content, positionTarget);
      },

      hideTooltip: function () {
        if ( this.epaper.$.tooltip.hide !== undefined ) {
          this.epaper.$.tooltip.hide();
        }
      }

    });
  </script>
</dom-module>