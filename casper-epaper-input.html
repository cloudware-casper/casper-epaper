<!--
  - Copyright (c) 2016 Neto Ranito & Seabra LDA. All rights reserved.
  -
  - This file is part of casper-combolist.
  -
  - casper-combolist is free software: you can redistribute it and/or modify
  - it under the terms of the GNU Affero General Public License as published by
  - the Free Software Foundation, either version 3 of the License, or
  - (at your option) any later version.
  -
  - casper-combolist  is distributed in the hope that it will be useful,
  - but WITHOUT ANY WARRANTY; without even the implied warranty of
  - MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  - GNU General Public License for more details.
  -
  - You should have received a copy of the GNU Affero General Public License
  - along with casper-combolist.  If not, see <http://www.gnu.org/licenses/>.
  -
 -->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-autogrow-textarea/iron-autogrow-textarea.html">

<!--
`casper-epaper-input` customised input component that overlays the rendering canvas
-->
<dom-module id="casper-epaper-input">
  <style type>
    :host {
      display: inline-block;
      position: absolute;
    }

    iron-autogrow-textarea {
      border: none;
      padding: 0px;
      margin: 0px;
      tabindex: 0;
    }

  </style>
  <template>
    <iron-autogrow-textarea id="input"></iron-autogrow-textarea>
  </template>
  <script>
    Polymer({
      is: 'casper-epaper-input',

      listeners: {
        'keypress': '_onKeypress',
        'keydown': '_onKeyDown'
      },

      attached: function () {
        this._textArea         = this.$.input.$.textarea;
        this._initialSelection = false;
        this._mode             = 'n';
      },

      detached: function () {
        //this.unlisten(this._textArea, 'keydown', '_onKeyDown');
      },

      /**
       * Position and size the input overlay on top the editable element
       *
       * @param a_x Upper left corner (x)
       * @param a_y Upper left corner (y)
       * @param a_width box width in px
       * @param a_height box height in px
       */
      alignPosition: function (a_x, a_y, a_w, a_h) {
        this.style.left      = a_x / 2 + 'px';
        this.style.top       = a_y / 2 + 'px';  // TODO SCALLING!
        this.style.width     = a_w / 2 + 'px';
        this.style.height    = a_h / 2 + 'px';
        this._textArea.style.left   = '0px';
        this._textArea.style.top    = '0px';
        this._textArea.style.width  = a_w / 2 + 'px'; // TODO SCALLING!
        this._textArea.style.height = a_h / 2 + 'px';
      },

      /**
       * @param a_text_left    Starting point of left aligned text # TODO paddding
       * @param a_baseline     Vertical baseline of the first text line # TODO remove??? or do PADDING?
       * @param a_baseline    Maximum width of the text #TODO remove?
       */
      alignStyle: function (a_text_left, a_baseline, a_baseline) {
        this._textArea.style.margin = '1px';
        this._textArea.style.fontFamily = this._epaper._font_spec[this._epaper._FONT_NAME_INDEX];
        this._textArea.style.fontSize   = this._epaper._font_spec[this._epaper._SIZE_INDEX] / 2 + 'px'; // TODO SCALLING
        this._textArea.style.color      = this._epaper._text_color;
      },

      /**
       * Configure the editor mode
       *
       * @param a_mode The editor mode
       * @param a_nullable_list The combo box list can be nulled
       */
      setMode: function (a_mode, a_nullable_list) {
        this._mode = a_mode;
        switch ( a_mode ) {
        case 'c': // Client combo
          this._cursor_type = 'pointer';
          break;

        case 'l': // Ledger mode
          this._cursor_type = 'text';
          break;

        case 'd': // Date

          this._cursor_type = 'text';
          break;

        case 'R':

          this._cursor_type = 'pointer';
          break;

        default:
          this._mode        = 'n'
          this._cursor_type = 'text';
          break;
        }
      },

      setValue: function (a_value) {
        this._textArea.value          = a_value;
        this._textArea.selectionStart = 0;
        this._textArea.selectionEnd   = a_value.length;
        this._initialSelection        = true;
      },

      _onKeypress: function (a_event) {
        //console.log(a_event);
      },

      _onKeyDown: function (a_event) {
        var vkey = this._keycodeToVkey(a_event);

        if ( this._initialSelection === true ) {
          if ( ['down', 'up', 'left', 'right'].indexOf(vkey) > -1 ) {
            this._epaper.send_command('set key "focus_'+vkey+'";');
            a_event.preventDefault();
            return;
          }Â else if ( vkey === 'tab' || vkey === 'shift+tab' ) {
            this._epaper.send_command('set key "'+vkey.replace(/\+/g, '"+"')+'";');
            a_event.preventDefault();
            return;
          } else if ( vkey === 'enter' || vkey === 'F2' ) {
            this._textArea.selectionStart = this._textArea.value.length;
            this._textArea.selectionEnd   = this._textArea.value.length;
            a_event.preventDefault();
            this._initialSelection = false;
            return;
          } else {
            this._initialSelection = false;
          }
        }

        if ( ['enter', 'tab', 'shift+tab'].indexOf(vkey) > -1 ) {
          this._epaper.send_command('set text "' + this._escapeForServer(this._textArea.value) + '" true; set key "'
                                      + vkey.replace(/\+/g, '"+"') + '";');
          a_event.preventDefault();
          return;
        }
        //console.log("down " + this._keycodeToVkey(a_event));
      },

      _escapeForServer:  function (a_text) {
        return a_text.split('"').join('""');
      },

      /**
       * Convert keycode to virtual key code that is understood by the server
       *
       * @param a_event The Keyboard event
       *
       * @return the virtual key name or null if there no mapping
       */
      _keycodeToVkey: function (a_event) {
        switch (a_event.keyCode) {
        case  8: // backspace
          return 'backspace';
        case  9: // tab
          if ( a_event.shiftKey === true ) {
            return 'shift+tab';
          } else {
            return 'tab';
          }
          break;
        case 13: // enter
          return 'enter';
        case 27: // escape
          return 'esc';
        case 32: // space
          return ' ';
        case 37: // left
          return 'left';
        case 39: // right
          return 'right';
        case 38: // up
          if ( a_event.shiftKey === true ) {
            return 'shift+up';
          } else {
            return 'up';
          }
          break;
        case 40: // down
          if ( a_event.shiftKey === true ) {
            return 'shift+down';
          } else {
            return 'down';
          }
          break;
        case 46:
          return 'delete';
        case 65:
          if ( a_event.ctrlKey ) {
            return 'ctrl+a';
          }
          break;
        case 69:
          if ( a_event.ctrlKey ) {
            return 'ctrl+e';
          }
          break;
        case 75:
          if ( a_event.ctrlKey ) {
            return 'ctrl+k';
          }
          break;
        case 113:
          return 'F2';
        case 16:
          return 'shift';
        case 17:
          return 'ctrl';
        case 18:
          return 'alt';
        case 91:
          return 'window+left';
        case 92:
          return 'window+right';
        default:
          break;
        }
        return null;
      }

    });
  </script>
</dom-module>