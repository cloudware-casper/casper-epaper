<!--
  - Copyright (c) 2016 Neto Ranito & Seabra LDA. All rights reserved.
  -
  - This file is part of casper-combolist.
  -
  - casper-combolist is free software: you can redistribute it and/or modify
  - it under the terms of the GNU Affero General Public License as published by
  - the Free Software Foundation, either version 3 of the License, or
  - (at your option) any later version.
  -
  - casper-combolist  is distributed in the hope that it will be useful,
  - but WITHOUT ANY WARRANTY; without even the implied warranty of
  - MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  - GNU General Public License for more details.
  -
  - You should have received a copy of the GNU Affero General Public License
  - along with casper-combolist.  If not, see <http://www.gnu.org/licenses/>.
  -
 -->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-autogrow-textarea/iron-autogrow-textarea.html">
<link rel="import" href="../vaadin-date-picker/vaadin-date-picker-light.html">

<!--
`casper-epaper-input` customised input component that overlays the rendering canvas
-->
<dom-module id="casper-epaper-input">
  <style type>
    :host {
      display: inline-block;
      position: absolute;
    }

    iron-autogrow-textarea {
      border: none;
      padding: 0px;
      margin: 0px;
      outline: none;
    }

  </style>
  <template>
    <iron-autogrow-textarea id="input" tabindex="0"></iron-autogrow-textarea>
    <casper-combolist id="combo" ></casper-combolist>
    <vaadin-date-picker-light id="date">
    </vaadin-date-picker-light>
  </template>
  <script>
    Polymer({
      is: 'casper-epaper-input',

      listeners: {
        'keypress': '_onKeypress',
        'keydown': '_onKeyDown',
        'tap': '_onTap'
      },

      ready: function () {
        var textArea       = this.$.input.$.textarea;
        this._input        = this.$.input;
        this._textArea     = this.$.input.$.textarea;
        this._comboBoxList = this.$.combo;
        this._date         = this.$.date;
        this._comboBoxList.setPositionTarget(this.$.input);
        this._date._input  = function () {
          return textArea;
        };
        this._date.positionTarget = this.$.input;
      },

      attached: function () {
        this._initialSelection = false;
        this._mode             = 'n';
        this._comboFilter      = '';
        this._overlayVisible   = false;
        this.listen(this._comboBoxList, 'on-combo-list-closed'      , '_onComboListClosed');
        this.listen(this._comboBoxList, 'on-combo-selection-changed', '_onComboSelectionChanged');
      },

      detached: function () {
        this.unlisten(this._comboBoxList, 'on-combo-list-closed'      , '_onComboListClosed');
        this.unlisten(this._comboBoxList, 'on-combo-selection-changed', '_onComboSelectionChanged');
      },

      /**
       * Position and size the input overlay on top the editable element
       *
       * @param a_x Upper left corner (x)
       * @param a_y Upper left corner (y)
       * @param a_width box width in px
       * @param a_height box height in px
       */
      alignPosition: function (a_x, a_y, a_w, a_h) {
        this.style.left          = a_x / 2 + 'px';
        this.style.top           = a_y / 2 + 'px';  // TODO SCALLING!
        this.style.width         = a_w / 2 + 'px';
        this.style.height        = a_h / 2 + 'px';
        this._input.style.left   = '0px';
        this._input.style.top    = '0px';
        this._input.style.width  = a_w / 2 + 'px'; // TODO SCALLING!
        this._input.style.height = a_h / 2 + 'px';
      },

      /**
       * @param a_text_left    Starting point of left aligned text # TODO paddding
       * @param a_baseline     Vertical baseline of the first text line # TODO remove??? or do PADDING?
       * @param a_baseline    Maximum width of the text #TODO remove?
       */
      alignStyle: function (a_text_left, a_baseline, a_baseline) {
        this._textArea.style.margin     = '1px';
        this._textArea.style.fontFamily = this._epaper._font_spec[this._epaper._FONT_NAME_INDEX];
        this._textArea.style.fontSize   = this._epaper._font_spec[this._epaper._SIZE_INDEX] / 2 + 'px'; // TODO SCALLING
        this._textArea.style.color      = this._epaper._text_color;
      },

      /**
       * Configure the editor mode
       *
       * @param a_mode The editor mode
       * @param a_nullable_list The combo box list can be nulled
       */
      setMode: function (a_mode, a_nullable_list) {
        this._comboFilter = '';
        this._mode        = a_mode;
        switch ( a_mode ) {
        case 'c': // Client combo
          this._textArea.style.cursor = 'pointer';
          break;
        case 'l': // Ledger mode
          this._textArea.style.cursor = 'text';
          break;
        case 'd': // Date
          this._textArea.style.cursor = 'text';
          break;
        case 'R': // Radio
          this._textArea.style.cursor = 'pointer';
          break;
        default: // Normal mode the default
          this._textArea.style.cursor = 'text';
          this._mode = 'n'
          break;
        }
      },

      /**
       * Sets the name of the data model field that contains the item description
       *
       * @param a_display_fields array of fields names
       */
      setDisplayFields: function (a_fields) {
        this._comboBoxList.setDisplayFields(a_fields);
      },

      /**
       * Show / hide the combo box list
       */
      _toggleComboList: function () {

        if ( this._comboBoxList.isVisible() ) {
          this._comboBoxList.setVisible(false);
        } else {
          var sc = this._epaper._ratio;
          var page_margin = 40 * this._epaper._ratio;
          var max_width, max_height;

          var left  = parseInt(this.style.left);
          var width = parseInt(this.style.width);

          if ( (left / this._epaper._sx) > this._epaper._page_width / 2 ) {
            max_width = left + width /*+ this._open_combo_button._bb_w*/ - page_margin;
          } else {
            max_width = this._epaper._page_width * this._epaper._sx - page_margin - left;
          }

          //if ( (this.style.top / this._epaper._sy) > this._epaper._page_height / 2 ) {
          //  max_height = this.style.top  - page_margin;
          //} else {
          //  max_height = this._epaper._page_height * this._epaper._sx - page_margin - this._bb_y -  this._bb_h;
          //}

          //this._tooltip.set_visible(false);
          this._comboBoxList.autoSize(width, max_width);
          this._comboBoxList.setVisible(true, this._comboFilter);
        }
        this._overlayVisible = this._comboBoxList.isVisible();
      },

      _onComboSelectionChanged: function (a_event) {
        if ( a_event.detail.displayValue ) {
          this._textArea.value = a_event.detail.displayValue;
          if ( this._mode === 'c' && this._overlayVisible === false) {
            this._textArea.selectionStart = a_event.detail.matchStart;
            this._textArea.selectionEnd   = a_event.detail.matchEnd;
          }
        }
      },

      _onComboListClosed: function (a_event) {
        var key;

        this._overlayVisible = false;
        this._comboFilter    = '';

        key = a_event.detail.keyCode;
        if ( a_event.detail.selectedId !== undefined && a_event.detail.selectedId !== a_event.detail.previousId ) {
          this._epaper.send_command('set list item "' + a_event.detail.selectedId  + '";');
          if ( key === 'shift+tab' ) {
            this._epaper.send_command('set key "shift"+"tab";');
          } else if ( key === 'enter' || key === 'tab' ) {
            this._epaper.send_command('set key "tab";');
          } else {
            this._epaper.send_command('set key "save";');
          }
        } else {
          if ( key === 'shift+tab' ) {
            this._epaper.send_command('set key "focus_left";');
          } else if ( key === 'enter' || key === 'tab' ) {
            this._epaper.send_command('set key "focus_right";');
          }
        }
        this._textArea.focus();
      },

      /**
       * Sets the basic the combo item list
       *
       * Each model is associated with an id, models are kept in a model cache. To set a model the
       * server specified the id and json model, to reuse a cached model just sends the id.
       *
       * @param a_combo_id Unique identifier of the combo list in the document (no caching if it's undefined)
       * @param a_json json string with the data model to associate with the combo it. If this parameter is
       *               undefined the model is retrieved from the _modelCache
       */
      setModelFromJson: function (a_combo_id, a_json) {
        return this._comboBoxList.setModelFromJson(a_combo_id, a_json);
      },

      setValue: function (a_value) {
        switch ( this._mode) {
          case 'c':
            this._setValueC(a_value);
            break;
          case 'n':
          default:
            this._setValueN(a_value);
            break;
        }
      },

      grabFocus: function () {
        if ( this._initialSelection === true ) {
          if ( this._mode === 'c' ) {
            this._textArea.selectionStart = undefined;
            this._textArea.selectionEnd   = undefined;
          } else {
            this._textArea.selectionStart = 0;
            this._textArea.selectionEnd   = this._textArea.value.length;
          }
        }
        this._textArea.focus();
      },


      _onTap: function (a_event) {
        switch ( this._mode) {
          case 'c':
            this._toggleComboList();
            a_event.preventDefault();
            break;
          case 'd':
            this._date.open();
            break;
          default:
            break;
        }
      },

      _onKeypress: function (a_event) {
        switch ( this._mode) {
          case 'c':
            this._onKeypressC(a_event);
            break;
          //case 'l': // TODO LEDGER MODE
          //  this._onKeyDown_l(a_event);
          //  break;
          case 'n':
          default:
            break;
        }
      },

      _onKeyDown: function (a_event) {
        switch ( this._mode) {
          case 'c':
            this._onKeyDownC(a_event);
            break;
          //case 'l': // TODO LEDGER MODE
          //  this._onKeyDown_l(a_event);
          //  break;
          case 'n':
          default:
            this._onKeyDownN(a_event);
            break;
        }
      },

      /*****************************************************************************************/
      /*                                                                                       */
      /*                             ~~~ N Mode Normal Mode ~~~                                */
      /*                                                                                       */
      /*****************************************************************************************/

      _setValueN: function (a_value) {
        this._textArea.value          = a_value;
        this._textArea.selectionStart = 0;
        this._textArea.selectionEnd   = a_value.length;
        this._initialSelection        = true;
      },

      _onKeyDownN: function (a_event) {
        var vkey = this._keycodeToVkey(a_event);

        if ( this._initialSelection === true ) {
          if ( ['down', 'up', 'left', 'right'].indexOf(vkey) > -1 ) {
            this._epaper.send_command('set key "focus_'+vkey+'";');
            a_event.preventDefault();
            return;
          } else if ( ['tab', 'shift+tab'].indexOf(vkey) > -1 ) {
            this._epaper.send_command('set key "'+vkey.replace(/\+/g, '"+"')+'";');
            a_event.preventDefault();
            return;
          } else if ( ['enter', 'F2'].indexOf(vkey) > -1 ) {
            this._textArea.selectionStart = this._textArea.value.length;
            this._textArea.selectionEnd   = this._textArea.value.length;
            this._initialSelection = false;
            a_event.preventDefault();
            return;
          } else {
            this._initialSelection = false;
          }
        }

        if ( ['enter', 'tab', 'shift+tab'].indexOf(vkey) > -1 ) {
          this._epaper.send_command('set text "' + this._escapeForServer(this._textArea.value) + '" true; set key "'
                                      + vkey.replace(/\+/g, '"+"') + '";');
          a_event.preventDefault();
          return;
        }
      },

      /*****************************************************************************************/
      /*                                                                                       */
      /*                             ~~~ C Mode Client Combo ~~~                               */
      /*                                                                                       */
      /*****************************************************************************************/

      _setValueC: function (a_id) {
        this._comboBoxList.setVisible(false);
        this._comboBoxList.selectById(a_id);
        this._overlayVisible = false;
        this._textArea.selectionStart = undefined;
        this._textArea.selectionEnd   = undefined;
      },

      _onKeypressC: function (a_event) {
        if ( this._overlayVisible === false ) {
          this._comboFilter += a_event.key;
          this._comboBoxList.setQuery(this._comboFilter);
          a_event.preventDefault();
        }
      },

      _onKeyDownC: function (a_event) {
        var vkey;

        vkey = this._keycodeToVkey(a_event);
        if ( this._overlayVisible === false ) {
          if ( ['down', 'up', 'left', 'right'].indexOf(vkey) > -1 ) {
            if ( this._comboFilter.length !== 0 && ['down', 'up'].indexOf(vkey) > -1) {
              this._comboBoxList.moveSelection(vkey);
            } else {
              this._epaper.send_command('set key "focus_'+vkey+'";');
            }
            a_event.preventDefault();
          } else if ( ['tab', 'shift+tab', 'enter'].indexOf(vkey) > -1 ) {
            if ( this._comboBoxList.getSelectedId() && this._comboBoxList.getSelectedId() !== this._comboBoxList.getInitialId() ) {
              this._epaper.send_command('set list item "' + this._comboBoxList.getSelectedId()  + '";');
            }
            this._epaper.send_command('set key "'+vkey.replace(/\+/g, '"+"')+'";');
            a_event.preventDefault();
          } else if ( vkey === 'alt' ) {
            this._toggleComboList();
          } else if ( ['delete', 'backspace'].indexOf(vkey) > -1 ) {
            this._comboFilter = this._comboFilter.slice(0, -1);
            this._comboBoxList.setQuery(this._comboFilter, false);
            a_event.preventDefault();
          }
        } else {
          if ( vkey === 'esc' ) {
            this._comboBoxList.setVisible(false);
            this._overlayVisible = false;
            a_event.preventDefault();
          }
        }
      },

      /**
       * Escapes double quotes for the server protocol
       */
      _escapeForServer:  function (a_text) {
        return a_text.split('"').join('""');
      },

      /**
       * Convert keycode to virtual key code that is understood by the server
       *
       * @param a_event The Keyboard event
       *
       * @return the virtual key name or null if there no mapping
       */
      _keycodeToVkey: function (a_event) {
        switch (a_event.keyCode) {
        case  8: // backspace
          return 'backspace';
        case  9: // tab
          if ( a_event.shiftKey === true ) {
            return 'shift+tab';
          } else {
            return 'tab';
          }
          break;
        case 13: // enter
          return 'enter';
        case 27: // escape
          return 'esc';
        case 32: // space
          return ' ';
        case 37: // left
          return 'left';
        case 39: // right
          return 'right';
        case 38: // up
          if ( a_event.shiftKey === true ) {
            return 'shift+up';
          } else {
            return 'up';
          }
          break;
        case 40: // down
          if ( a_event.shiftKey === true ) {
            return 'shift+down';
          } else {
            return 'down';
          }
          break;
        case 46:
          return 'delete';
        case 65:
          if ( a_event.ctrlKey ) {
            return 'ctrl+a';
          }
          break;
        case 69:
          if ( a_event.ctrlKey ) {
            return 'ctrl+e';
          }
          break;
        case 75:
          if ( a_event.ctrlKey ) {
            return 'ctrl+k';
          }
          break;
        case 113:
          return 'F2';
        case 16:
          return 'shift';
        case 17:
          return 'ctrl';
        case 18:
          return 'alt';
        case 91:
          return 'window+left';
        case 92:
          return 'window+right';
        default:
          break;
        }
        return null;
      }

    });
  </script>
</dom-module>