<!--
  - Copyright (c) 2016 Neto Ranito & Seabra LDA. All rights reserved.
  -
  - This file is part of casper-combolist.
  -
  - casper-combolist is free software: you can redistribute it and/or modify
  - it under the terms of the GNU Affero General Public License as published by
  - the Free Software Foundation, either version 3 of the License, or
  - (at your option) any later version.
  -
  - casper-combolist  is distributed in the hope that it will be useful,
  - but WITHOUT ANY WARRANTY; without even the implied warranty of
  - MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  - GNU General Public License for more details.
  -
  - You should have received a copy of the GNU Affero General Public License
  - along with casper-combolist.  If not, see <http://www.gnu.org/licenses/>.
  -
 -->

<link rel="import" href="../polymer/polymer.html">

<!--
`casper-epaper-tooltip` customised input component that overlays the rendering canvas
-->
<dom-module id="casper-epaper-tooltip">
  <template>
    <style>
      :host {
        display: none;
        position: absolute;
        -moz-user-select: none;
        -ms-user-select: none;
        -webkit-user-select: none;
        user-select: none;
        width: 345px;
      }

      #canvas {
        display:  block;
        position: absolute;
      }

      #text {
        display: block;
        position: absolute;
        padding: 5px;
        text-align: center;
        color: white;
        font-size: 10px;
      }

    </style>
    <canvas id="canvas">
    </canvas>
    <div id="text">
    <div>
  </template>
  <script>
    Polymer({
      is: 'casper-epaper-tooltip',

      properties: {
        radius: {
          type: Number,
          value: 5
        },
        tipHeight: {
          type: Number,
          value: 5
        },
        tipBase: {
          type: Number,
          value: 10
        },
        tipLocation: {
          type: Number,
          value: 0.5
        },
        tipEdge: {
          type: String,
          value: 'N'
        }
      },

      ready: function() {
        this._ctx = this.$.canvas.getContext('2d');
        this._ctx.globalCompositeOperation = 'copy';
        this._setupPixelRatio();
      },

      /**
       * Define the tooltip location
       *
       * @param left horizontal position
       * @param top vertical position
       */
      setLocation: function (left, top) {
        this.style.left = left + 'px';
        this.style.top  = top  + 'px';
        this.updateStyles();
      },

      setTipLocation: function (loc) {
        this.tipLocation = loc;
      },

      setVisible: function (visible) {
        this.style.display = visible ? 'block' : 'none';
      },

      setText: function (html, max_width) {
        if (max_width !== undefined ) {
          this.style.width = max_width + 'px';
        }
        this.$.text.style.margin = '0px';
        switch(this.tipEdge) {
          case 'N':
          default:
            this.$.text.style.marginTop = this.tipHeight + 'px';
            break;
          case 'S':
            this.$.text.style.marginBottom = this.tipHeight + 'px';
            break;
          case 'W':
            this.$.text.style.marginLeft = this.tipHeight + 'px';
            break;
          case 'E':
            this.$.text.style.marginRight = this.tipHeight + 'px';
            break;
        }
        Polymer.dom(this.$.text).innerHTML = html;
      },

      updateBalloon: function () {
        var width, height, bb;

        bb = this.$.text.getBoundingClientRect();
        switch(this.tipEdge) {
          case 'N':
          case 'S':
            height = bb.height + this.tipHeight;
            width  = bb.width;
            break;
          case 'W':
          case 'E':
            height = bb.height;
            width  = bb.width + this.tipHeight + this.radius;
            break;
        }
        this.$.canvas.width = width * this._ratio;
        this.$.canvas.height = height * this._ratio;
        this.$.canvas.style.width  = width + 'px';
        this.$.canvas.style.height = height + 'px';
        this._paintBalloon(width, height);
      },

      /**
       * @brief Determine the device pixel ratio: 1 on classical displays 2 on retina/UHD displays
       */
      _setupPixelRatio: function () {
        var devicePixelRatio  = window.devicePixelRatio || 1;
        if (devicePixelRatio > 1.6) {
          devicePixelRatio = 2;
        } else {
          devicePixelRatio = 1;
        }
        var backingStoreRatio = this._ctx.webkitBackingStorePixelRatio ||
                                this._ctx.mozBackingStorePixelRatio ||
                                this._ctx.msBackingStorePixelRatio ||
                                this._ctx.oBackingStorePixelRatio ||
                                this._ctx.backingStorePixelRatio || 1;
        this._ratio = devicePixelRatio / backingStoreRatio;
      },

      /**
       * @brief Prepares a rounded rect path, does not paint or stroke it
       *
       * @param x upper left corner
       * @param y upper left corner
       * @param w width of the round rectangle
       * @param h height of the round rectangle
       * @param r corner radius
       */
      _makeRoundRectPath: function (x, y, w, h, r) {
        this._ctx.moveTo( x + r, y );
        this._ctx.arcTo(  x + w, y    , x + w    , y + r    , r);
        this._ctx.arcTo(  x + w, y + h, x + w - r, y + h    , r);
        this._ctx.arcTo(  x    , y + h, x        , y + h - r, r);
        this._ctx.arcTo(  x    , y    , x + r    , y        , r);
      },

      _paintBalloon: function (width, height) {
        var tipLocation, tipHeight, tipBase, radius;

        this._ctx.fillStyle = '#000';
        this._ctx.globalAlpha = 0.75;

        radius    = this.radius    * this._ratio;
        tipHeight = this.tipHeight * this._ratio;
        tipBase   = this.tipBase   * this._ratio;
        width    *= this._ratio;
        height   *= this._ratio;
        this._ctx.beginPath();
        switch (this.tipEdge) {
          case 'N':
          default:
            this._makeRoundRectPath(0, 0 + tipHeight, width, height - tipHeight, radius);
            tipLocation = Math.round(0 + width * this.tipLocation);
            this._ctx.moveTo(tipLocation, 0);
            this._ctx.lineTo(tipLocation + Math.round(tipBase / 2), 0 + tipHeight);
            this._ctx.lineTo(tipLocation - Math.round(tipBase / 2), 0 + tipHeight);
            this._ctx.lineTo(tipLocation, 0);
            break;
          case 'E':
            this._makeRoundRectPath(0, 0, width - tipHeight, height, radius);
            tipLocation = Math.round(0 + height * this.tipLocation);
            this._ctx.moveTo(0 + width, tipLocation);
            this._ctx.lineTo(0 + width - tipHeight, Math.round(tipLocation - tipBase/ 2));
            this._ctx.lineTo(0 + width - tipHeight, Math.round(tipLocation + tipBase/ 2));
            this._ctx.lineTo(0 + width, tipLocation);
            break;
          case 'S':
            this._makeRoundRectPath(0, 0, width, height - tipHeight, radius);
            tipLocation = Math.round(0 + width * this.tipLocation);
            this._ctx.moveTo(tipLocation, 0 + height);
            this._ctx.lineTo(tipLocation + Math.round(tipBase / 2), 0 + height - tipHeight);
            this._ctx.lineTo(tipLocation - Math.round(tipBase / 2), 0 + height - tipHeight);
            this._ctx.lineTo(tipLocation, 0 + height);
            break;
          case 'W':
            this._makeRoundRectPath(0 + tipHeight, 0, width - tipHeight, height, radius);
            tipLocation = Math.round(0 + height * this.tipLocation);
            this._ctx.moveTo(0, tipLocation);
            this._ctx.lineTo(0 + tipHeight, Math.round(tipLocation - tipBase/ 2));
            this._ctx.lineTo(0 + tipHeight, Math.round(tipLocation + tipBase/ 2));
            this._ctx.lineTo(0, tipLocation);
            break;
        }
        this._ctx.closePath();
        this._ctx.fill();
      },


    });
  </script>
</dom-module>